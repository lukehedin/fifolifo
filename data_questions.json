{"questions":[{"id":1,"questionText":"What is ES6?","questionCode":null,"difficulty":1,"codeResponse":false,"copyCode":false,"tags":["JavaScript","es6"],"answer":"ES6 is a new set of Javascript standards, enhancing the language and its capabilities.","enabled":true,"archived":false},{"id":2,"questionText":"What is an ES6 Map and what are its advantages?","questionCode":"","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["JavaScript","es6"],"answer":"An ES6 Map is an alternate way of holding a set key-value pairs. \n\nMaps can use objects, functions and arrays as keys. Maps also allow easy interaction with keys and values using properties (eg. .size) and iteration methods (eg.  for (let key of myMap.keys()) {}).","enabled":true,"archived":false},{"id":3,"questionText":"What is an ES6 Set and what are its advantages?","questionCode":"","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","es6"],"enabled":true,"answer":"An ES6 Set is an alternate way of holding a series of values.\n\nSets must have unique values, so they are particularly useful for distincting values in an array."},{"id":4,"questionText":"Write a function with some default parameters.","questionCode":"","difficulty":1,"codeResponse":true,"copyCode":false,"tags":["javascript","es6"],"enabled":true,"answer":"function multiply(number, multiplyBy = 10, optionalAdd = 0){\n\treturn (number * multiplyBy) + optionalAdd;\n};"},{"id":5,"questionText":"What is the JavaScript event loop?","questionCode":"","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","cs"],"enabled":true,"answer":"When the call stack is empty, the browser looks for the first thing on the task queue and then puts it onto the call stack. This is the event loop."},{"id":6,"questionText":"Rewrite the following using arrow syntax.","questionCode":"let area = function(length, width) {\n\treturn length * width;\n}","difficulty":1,"codeResponse":true,"copyCode":false,"tags":["javascript","es6"],"enabled":true,"answer":"let area = (length, width) => length * width;"},{"id":7,"questionText":"What is the difference between undefined and not defined in JavaScript?","questionCode":"","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"In JavaScript, if you try to use a variable that doesn’t exist and has not been declared, then JavaScript will throw an error var name is not defined and script will stop executing. However, if you use typeof undeclared_variable, then it will return undefined."},{"id":8,"questionText":"What will be the output of the code below?","questionCode":"var y = 1;\n if (function f(){}) {\n   y += typeof f;\n }\n console.log(y);","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"The output would be 1undefined\n\nThe if condition statement evaluates using eval, so eval(function f(){}) returns function f(){} (which is true). Therefore, inside the if statement, executing typeof f returns undefined because the if statement code executes at run time, and the statement inside the if condition is evaluated during run time."},{"id":9,"questionText":"What is the drawback of creating true private methods in JavaScript?","questionCode":"var Employee = function (name, company, salary) {\n    this.name = name || \"\";       //Public attribute default value is null\n    this.company = company || \"\"; //Public attribute default value is null\n    this.salary = salary || 5000; //Public attribute default value is null\n    // Private method\n    var increaseSalary = function () {\n        this.salary = this.salary + 1000;\n    };\n    // Public method\n    this.dispalyIncreasedSalary = function() {\n        increaseSlary();\n        console.log(this.salary);\n    };\n};","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"One of the drawbacks of creating true private methods in JavaScript is that they are very memory-inefficient, as a new copy of the method would be created for each instance."},{"id":10,"questionText":"What is a “closure” in JavaScript?","questionCode":"","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"A closure is a function defined inside another function (called the parent function), and has access to variables that are declared and defined in the parent function scope."},{"id":11,"questionText":"Write a mul function which will produce the following outputs when invoked:","questionCode":"console.log(mul(2)(3)(4)); // output : 24 \nconsole.log(mul(4)(3)(4)); // output : 48","difficulty":1,"codeResponse":true,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"function mul (x) {\n    return function (y) { // anonymous function \n        return function (z) { // anonymous function \n            return x * y * z; \n        };\n    };\n}\n\n//Explanation\n\nHere the mul function accepts the first argument and returns an anonymous function, which takes the second parameter and returns another anonymous function that will take the third parameter and return the multiplication of the arguments that have been passed.\n\nIn JavaScript, a function defined inside another one has access to the outer function’s variables. Therefore, a function is a first-class object that can be returned by other functions as well and be passed as an argument in another function."},{"id":12,"questionText":"What is the difference between arrayList.length = 0; and arrayList = []?","questionCode":null,"difficulty":1,"codeResponse":true,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"arrayList.length = 0;\narrayList.splice(0, arrayList.length);\n\nThe code above will clear the existing array by setting its length to 0. This way of emptying the array also updates all the reference variables that point to the original array. Therefore, this method is useful when you want to update all reference variables pointing to arrayList.\n\n\narrayList = [];\n\nThis is recommended if you don’t have references to the original array arrayList anywhere else, because it will actually create a new, empty array. You should be careful with this method of emptying the array, because if you have referenced this array from another variable, then the original reference array will remain unchanged.\n\n\n"},{"id":13,"questionText":"How do you check if an object is an array or not?","questionCode":null,"difficulty":1,"codeResponse":true,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"Array.isArray(arrayList);\n"},{"id":14,"questionText":"What will be the output of the following code? Why?","questionCode":"var output = (function(x){\n    delete x;\n    return x;\n  })(0);\n  \n  console.log(output);","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"The output would be 0. The delete operator is used to delete properties from an object. Here x is not an object but a local variable. delete operators don’t affect local variables."},{"id":15,"questionText":"What will be the output of the following code?","questionCode":"var x = 1;\nvar output = (function(){\n    delete x;\n    return x;\n  })();\n  \n  console.log(output);","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"The output would be 1. The delete operator is used to delete the property of an object. Here x is not an object, but rather it’s the global variable of type number."},{"id":16,"questionText":"What will be the output of the code below?","questionCode":"var x = { foo : 1};\nvar output = (function(){\n    delete x.foo;\n    return x.foo;\n  })();\n  \n  console.log(output);\n","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"The output would be undefined. The delete operator is used to delete the property of an object. Here, x is an object which has the property foo, and as it is a self-invoking function, we will delete the foo property from object x. After doing so, when we try to reference a deleted property foo, the result isundefined."},{"id":17,"questionText":"What will be the output of the code below?","questionCode":"var Employee = {\n  company: 'xyz'\n}\nvar emp1 = Object.create(Employee);\ndelete emp1.company\nconsole.log(emp1.company);","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"The output would be xyz. Here, emp1 object has company as its prototype property. The delete operator doesn’t delete prototype property.\n\nemp1 object doesn’t have company as its own property. You can test it console.log(emp1.hasOwnProperty('company')); //output : false. However, we can delete the company property directly from theEmployee object using delete Employee.company. Or, we can also delete the emp1 object using the __proto__ property delete emp1.__proto__.company."},{"id":18,"questionText":"What will be the output of the code below?","questionCode":"var trees = [\"xyz\",\"xxxx\",\"test\",\"ryan\",\"apple\"];\ndelete trees[3];\n  \n  console.log(trees.length);","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"The output would be 5. When we use the delete operator to delete an array element, the array length is not affected from this. This holds even if you deleted all elements of an array using the delete operator.\n\nIn other words, when the delete operator removes an array element, that deleted element is not longer present in array. In place of value at deleted index undefined x 1 in chrome and undefined is placed at the index. If you do console.log(trees) output [\"xyz\", \"xxxx\", \"test\", undefined × 1, \"apple\"] in Chrome and in Firefox [\"xyz\", \"xxxx\", \"test\", undefined, \"apple\"]."},{"id":19,"questionText":"What will be the output of the code below?","questionCode":"var bar = true;\nconsole.log(bar + 0);   \nconsole.log(bar + \"xyz\");  \nconsole.log(bar + true);  \nconsole.log(bar + false);\n","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"The code will output 1, \"truexyz\", 2, 1. Here’s a general guideline for addition operators:\n\nNumber + Number -> Addition\nBoolean + Number -> Addition\nBoolean + Number -> Addition\nNumber + String -> Concatenation\nString + Boolean -> Concatenation\nString + String -> Concatenation"},{"id":20,"questionText":"What is undefined x 1 in JavaScript?","questionCode":"var trees = [\"redwood\",\"bay\",\"cedar\",\"oak\",\"maple\"];\ndelete trees[3];","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":false,"answer":"When you run the code above and type console.log(trees); into your Chrome developer console, you will get\n[\"redwood\", \"bay\", \"cedar\", undefined × 1, \"maple\"]. When you run the code in Firefox’s browser console, you will get [\"redwood\", \"bay\", \"cedar\", undefined, \"maple\"]. Thus, it’s clear that the Chrome browser has its own way of displaying uninitialised indexes in arrays. However, when you check trees[3] === undefined in both browsers, you will get similar output as true."},{"id":21,"questionText":"What will be the output of the code below?","questionCode":"var z = 1, y = z = typeof y;\nconsole.log(y);","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"The output would be undefined. According to the associativity rule, operators with the same precedence are processed based on the associativity property of the operator. Here, the associativity of the assignment operator is Right to Left, so typeof y will evaluate first , which is undefined. It will be assigned to z, and then y would be assigned the value of z and then z would be assigned the value 1."},{"id":22,"questionText":"What will be the output of the code below?","questionCode":"var foo = function bar(){ return 12; };\ntypeof bar();","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"The output would be Reference Error. To make the code above work, you can re-write it as follows:\n\nvar bar = function(){ return 12; };\ntypeof bar();\n\n//or\n\nfunction bar(){ return 12; };\ntypeof bar();\n\n\n//LH: The bar essentially gets lost entirely!"},{"id":23,"questionText":"What is difference between the function declarations below?","questionCode":"var foo = function(){ \n// Some code\n};\n\nfunction bar(){ \n// Some code\n};","difficulty":1,"codeResponse":true,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"The main difference is the function foo is defined at run-time whereas function bar is defined at parse time.\n\nfoo will not cause an error if it is specified twice, because it is read at run time\n\nbar WILL cause an error if it is specified twice because it is PARSED when the document reads it"},{"id":24,"questionText":"What is function hoisting in JavaScript?","questionCode":null,"difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"In JavaScript, variable and functions are hoisted. Let’s take function hoisting first. Basically, the JavaScript interpreter looks ahead to find all variable declarations and then hoists them to the top of the function where they’re declared. "},{"id":25,"questionText":"What will be the output of code below?","questionCode":"var salary = \"1000$\";\n(function () {\n    console.log(\"Original salary was \" + salary);\n    var salary = \"5000$\";\n    console.log(\"My New Salary \" + salary);\n})();","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript","js101"],"enabled":true,"answer":"The output would be undefined, 5000$. Newbies often get tricked by JavaScript’s hoisting concept. In the code above, you might be expecting salary to retain its value from the outer scope until the point that salary gets re-declared in the inner scope. However, due to hoisting, the salary value was undefined instead. "},{"id":26,"questionText":"Difference between function.call() and function.apply()?","questionCode":"","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["javascript"],"enabled":true,"answer":"he difference is that apply lets you invoke the function with arguments as an array; call requires the parameters be listed explicitly.\n\ntheFunction.apply(undefined, [\"Susan\", \"school teacher\"]);\ntheFunction.call(undefined, \"Claude\", \"mathematician\");"},{"id":27,"questionText":"What sort of data binding does React use?","questionCode":"","difficulty":1,"codeResponse":false,"copyCode":false,"tags":["react"],"enabled":true,"answer":"One-way data binding, the model (state) updates the view."}]}